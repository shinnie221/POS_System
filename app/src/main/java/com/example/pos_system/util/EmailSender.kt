package com.example.pos_system.util

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import java.io.File
import java.util.Properties
import javax.activation.DataHandler
import javax.activation.FileDataSource
import javax.mail.*
import javax.mail.internet.*

object EmailSender {

    //private const val SERVER_EMAIL = "shinniecheng221@gmail.com"
    //private const val SERVER_PASSWORD = "lxmfytvqbnwfapbp"
    private const val SERVER_EMAIL = "colfi.coffee@gmail.com"
    private const val SERVER_PASSWORD = "pcnevzctwfnbqecs"

    private fun createSession(): Session {
        val props = Properties().apply {
            put("mail.smtp.host", "smtp.gmail.com")
            put("mail.smtp.port", "465")
            put("mail.smtp.socketFactory.port", "465")
            put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory")
            put("mail.smtp.auth", "true")
        }

        return Session.getInstance(props, object : Authenticator() {
            override fun getPasswordAuthentication(): PasswordAuthentication {
                return PasswordAuthentication(SERVER_EMAIL, SERVER_PASSWORD)
            }
        })
    }

    private fun buildMessage(
        session: Session,
        toEmail: String,
        file: File,
        subjectTitle: String
    ): MimeMessage {

        val message = MimeMessage(session).apply {
            setFrom(InternetAddress(SERVER_EMAIL, "Colfi POS System"))
            setRecipient(Message.RecipientType.TO, InternetAddress(toEmail))
            subject = subjectTitle
        }

        val bodyPart = MimeBodyPart().apply {
            setText(
                "Please find the attached sales report.\n\n" +
                        "This email was automatically generated by Colfi POS System."
            )
        }

        val attachmentPart = MimeBodyPart().apply {
            dataHandler = DataHandler(FileDataSource(file))
            fileName = file.name
        }

        val multipart = MimeMultipart().apply {
            addBodyPart(bodyPart)
            addBodyPart(attachmentPart)
        }

        message.setContent(multipart)
        return message
    }

    /**
     * ✅ Sends TWO SEPARATE emails at the same time
     * ✅ No BCC / CC
     * ✅ Looks like server behavior
     */
    suspend fun sendReportToColfiAndShinnie(
        colfiEmail: String,
        shinnieEmail: String,
        file: File,
        subjectTitle: String
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val session = createSession()

            coroutineScope {
                val sendColfi = async {
                    Transport.send(
                        buildMessage(session, colfiEmail, file, subjectTitle)
                    )
                }

                val sendShinnie = async {
                    Transport.send(
                        buildMessage(session, shinnieEmail, file, subjectTitle)
                    )
                }

                sendColfi.await()
                sendShinnie.await()
            }

            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }
}
